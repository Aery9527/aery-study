鎖的流程

1. 偏向鎖 (-XX:-UseBiasedLocking 可以關閉偏向鎖使用)
    - 當前只有一個thread訪問同步區塊時, 這時就是偏向鎖, 而這個thread重入該同步區塊時不會再有上鎖/解鎖的開銷
    - 直到有其他thread要訪問同個同步區塊時, 這時偏向鎖才會被撤銷, 升級為輕量鎖
2. 輕量鎖 (-XX:+UseHeavyMonitors 將強制使用重量鎖, 其實也就意味著關閉輕量鎖)
    - 會使用CAS操作來嘗試獲得鎖, thread拿不到鎖則會不斷loop嘗試獲得鎖, 這種不讓thread進入阻塞/喚醒的狀態, 這樣的方式稱為"自旋"
    - 因為thread頻繁的阻塞/喚醒對CPU來說是更重的開銷, 所以優先採用自旋處理短時間內的競爭狀態, 可以避免thread進入阻塞與喚醒的狀態
    - 例如int的累加動作, 其拿鎖做事的時間很短, 對thread切換阻塞/喚醒的開銷就很不切實際, 應該採用自旋的處理方式
    - 由於自旋的thread是一直處於RUNNING狀態, 也就會消耗CPU, 因此在自旋的次數上有限制, 例如loop 10/100次就會升級為重量鎖
3. 重量鎖
    - 依賴OS的mutex來實現, 這時thread會進入阻塞/喚醒的狀態
    - 此時只有切換thread狀態的時候才會消耗CPU
4. 鎖的升級是單向的, 無法降低鎖的層級
5. 若存在大量thread競爭狀況, 注定要進入輕量鎖/重量鎖的話, 則偏向鎖的存在反而成為了額外的開銷, 因為多了升級鎖的流程 
